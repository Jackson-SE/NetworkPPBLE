% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/kNNinterp.R
\name{kNNinterp}
\alias{kNNinterp}
\title{k Nearest Neighbour interpolation.}
\usage{
kNNinterp(x, y, z, k = 10, algorithm = "kd_tree", p = 2)
}
\arguments{
\item{x}{a vector or matrix of values for which we wish to interpolate some output given \code{y} and \code{z}.}

\item{y}{a vector or matrix of values for which we have the output value of interest (given by \code{z}).}

\item{z}{a vector or matrix of output values corresponding to the points in \code{y}.}

\item{k}{the number of nearest neighbours we wish to average over.}

\item{algorithm}{nearest neighbour searching algorithm.}

\item{p}{the power to which we wish to take the distance of each point to its nearest neighbours to in the inverse distance average weighting.}
}
\value{
a vector or matrix (depending on the whether \code{z} was a vector or matrix) of the k nearest neighbour interpolated predictions.
}
\description{
k Nearest Neighbour interpolation.
}
\details{
If \code{y} or \code{z} are vectors, it is assumed that the corresponding input or output dimension (respectively) is 1.  If \code{x} is a vector, then if the dimension of \code{y} is 1, it is assumed to be a vector of points at which to predict, otherwise it is assumed to be a single point (with dimension equal to that of \code{y}) at which to predict.
}
\examples{
f <- function( y ){ c( sin( y[1] ) + cos( y[2] ), cos( y[1] ) + sin( y[2] ) ) }
y <- matrix( runif( 40 ), ncol = 2 )
z <- t( apply( y, 1, f ) )
x <- matrix( runif( 30 ), ncol = 2 )
kNNinterp( x, y, z )
kNNinterp( x, y, z[,1] )
kNNinterp( x[1,,drop=FALSE], y, z )
kNNinterp( x[1,], y, z )
}
\seealso{
\code{\link[FNN]{get.knnx}}
}
